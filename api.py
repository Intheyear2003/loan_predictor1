# api.py

import pandas as pd
import joblib
from fastapi import FastAPI, Depends, HTTPException, status
from fastapi.security import APIKeyHeader
from pydantic import BaseModel
import uvicorn
import os

# --- Authentication ---
API_KEY = os.getenv("API_KEY", "My_LoanApp_key_tmgN30rJ")
API_KEY_NAME = "X-API-Key"
api_key_header_auth = APIKeyHeader(name=API_KEY_NAME, auto_error=True)

async def get_api_key(api_key: str = Depends(api_key_header_auth)):
    if api_key != API_KEY:
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Invalid API Key")

# --- Input Data Model ---
class LoanApplication(BaseModel):
    credit_score: int
    credit_utilization: float  # Expects a float, e.g., 0.30 for 30%
    late_payments: int
    secured_loans: int
    unsecured_loans: int
    age: int
    credit_card_loan_account: int
    closed_account_count: int

# --- Load Model ---
try:
    model = joblib.load('final_model.joblib')
    MODEL_FEATURE_NAMES = model.feature_names_in_
except FileNotFoundError:
    print("ERROR: 'final_model.joblib' not found. Please run `train_model.py` first.")
    exit()

# --- FastAPI App ---
app = FastAPI(title="Loan Repayment Prediction API", version="2.0.0")

@app.get("/", tags=["Health Check"])
def read_root():
    return {"status": "ok", "api_version": app.version}

@app.post("/predict", summary="Get Loan Repayment Prediction", tags=["Prediction"], dependencies=[Depends(get_api_key)])
def predict_repayment(application: LoanApplication):
    input_features = application.model_dump()

    if application.credit_score < 600:
        return {"prediction_is_yes": False, "final_confidence_score": 0.05,
                "analysis": "Rule-based: Credit score is below the minimum threshold of 600.",
                "input_features": input_features}

    # Feature Engineering (must be IDENTICAL to train_model.py)
    distress_score = application.credit_utilization * (application.late_payments + 1)
    total_loans = application.secured_loans + application.unsecured_loans
    secured_loan_ratio = application.secured_loans / (total_loans + 1) if total_loans > 0 else 0
    debt_to_age_ratio = application.unsecured_loans / (application.age + 1)

    input_data = {
        'creditScore': [application.credit_score], 'creditUtilizationPercentage': [application.credit_utilization],
        'loanWithLatePaymentCount': [application.late_payments], 'securedLoanCount': [application.secured_loans],
        'unsecuredLoanCount': [application.unsecured_loans], 'age': [application.age],
        'creditCardLoanAccount': [application.credit_card_loan_account],
        'closedAccountCount': [application.closed_account_count],
        'distress_score': [distress_score], 'secured_loan_ratio': [secured_loan_ratio],
        'debt_to_age_ratio': [debt_to_age_ratio]
    }

    input_df = pd.DataFrame(input_data).reindex(columns=MODEL_FEATURE_NAMES, fill_value=0)
    final_proba = model.predict_proba(input_df)[0, 1]

    return {"prediction_is_yes": bool(final_proba > 0.5), "final_confidence_score": round(final_proba, 4),
            "analysis": "Prediction generated by an enhanced machine learning ensemble.",
            "input_features": input_features}

if __name__ == '__main__':
    uvicorn.run(app, host="0.0.0.0", port=8000)